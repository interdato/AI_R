---
title: "Demo: Inteligencia Artificial para Priorizar Leads"
subtitle: "De la predicci√≥n a la acci√≥n"
format:
  revealjs:
    slide-number: true
    transition: slide
    toc: false
    scrollable: true   # scroll vertical en cada slide
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

## üöÄ Contexto de negocio

-   En marketing B2B tenemos **miles de leads**.
-   El presupuesto y los equipos de ventas son **limitados**.
-   Pregunta clave: **¬øA qui√©n contactar para maximizar el retorno?**

------------------------------------------------------------------------

## üéØ Objetivo

-   Estimar la **probabilidad de compra** por lead (IA).
-   Calcular **valor esperado (EV)** de contacto.
-   Seleccionar leads bajo **presupuesto** (prescriptivo).
-   Sugerir **Next-Best Action** por segmento/comportamiento.

------------------------------------------------------------------------

## üß† Enfoque de IA

-   Modelo **XGBoost (gradient boosting)** para probabilidad de compra.
-   Variables de comportamiento y atributos:
    -   Visitas web, emails abiertos, tiempo en sitio
    -   Demos solicitadas, CSAT
    -   Segmento, regi√≥n, precio del plan

------------------------------------------------------------------------

## üîß Setup (librer√≠as y semilla)

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(pROC)
  library(xgboost)
  library(scales)
  library(knitr)
  library(DT)       # tablas con scroll
  library(htmltools)
  library(plotly)   # gr√°ficos que se ajustan mejor en m√≥vil
})

set.seed(2025)

# Mostrar versiones (contenido visible)
pkgs <- c("tidyverse","pROC","xgboost","scales","knitr","DT","plotly")
vers <- vapply(pkgs, function(p) as.character(utils::packageVersion(p)), character(1))
knitr::kable(tibble(Paquete = pkgs, Versi√≥n = vers), caption = "Paquetes cargados y versiones")
```

------------------------------------------------------------------------

## üß™ Datos sint√©ticos (B2B)

```{r}
n <- 4000
datos <- tibble(
  id_lead           = sprintf("L%05d", 1:n),
  segmento          = factor(sample(c("SMB","Mid","Enterprise"), n, TRUE, c(0.6,0.3,0.1))),
  visitas_web_30    = rpois(n, 4),
  emails_abiertos   = rpois(n, 2),
  tiempo_en_sitio   = rgamma(n, shape = 2, rate = 1/3),   # minutos
  demos_solicitadas = rbinom(n, 1, 0.15),
  csat              = pmin(10, pmax(1, round(rnorm(n, 7.6, 1.5)))),
  precio_plan       = sample(c(49, 99, 199, 399), n, TRUE, prob = c(0.5,0.3,0.15,0.05)),
  region            = factor(sample(c("NA","EU","APAC","LATAM"), n, TRUE))
) |>
  mutate(
    lp = -2.0 +
         0.20 * visitas_web_30 +
         0.25 * emails_abiertos +
         0.10 * tiempo_en_sitio +
         0.70 * demos_solicitadas +
         0.12 * (csat - 7.5) +
         case_when(segmento == "Mid" ~ 0.12,
                   segmento == "Enterprise" ~ 0.28,
                   TRUE ~ 0) +
         rnorm(n, 0, 0.5),
    p_compra_real = plogis(lp),
    compra = factor(rbinom(n, 1, p_compra_real), labels = c("no","si"))
  ) |>
  select(-lp)

knitr::kable(head(datos, 6), caption = "Muestra de datos sint√©ticos")
```

------------------------------------------------------------------------

## ‚úÇÔ∏è Partici√≥n & matrices para XGBoost

```{r}
set.seed(2025)
idx   <- sample.int(n, size = floor(0.75 * n))
train <- datos[idx, ]
test  <- datos[-idx, ]

# One-hot encoding con model.matrix (sin intercepto)
form    <- compra ~ . - id_lead
X_train <- model.matrix(form, data = train)[, -1, drop = FALSE]
X_test  <- model.matrix(form, data = test)[, -1, drop = FALSE]

y_train <- as.numeric(train$compra == "si")
y_test  <- as.numeric(test$compra == "si")

dtrain <- xgb.DMatrix(data = X_train, label = y_train)
dtest  <- xgb.DMatrix(data = X_test,  label = y_test)

# Res√∫menes visibles
resumen_mm <- tibble(
  Conjunto = c("Train","Test"),
  Filas    = c(nrow(X_train), nrow(X_test)),
  Columnas = c(ncol(X_train), ncol(X_test))
)

primeras_cols <- tibble(Columna = colnames(X_train))

tagList(
  tags$h4("Dimensiones de matrices (OHE)"),
  DT::datatable(
    resumen_mm,
    rownames = FALSE,
    options = list(dom = "t", paging = FALSE, autoWidth = TRUE),
    class = "display compact"
  ),
  tags$h4("Columnas de la matriz de dise√±o (train)"),
  DT::datatable(
    primeras_cols,
    rownames = FALSE,
    options = list(
      dom = "t",
      paging = FALSE,
      scrollY = "320px",
      scrollX = TRUE,
      autoWidth = TRUE
    ),
    class = "display nowrap compact"
  )
)
```

------------------------------------------------------------------------

## üèãÔ∏è Entrenamiento del modelo (XGBoost)

```{r}
params <- list(
  objective = "binary:logistic",
  eval_metric = "auc",
  max_depth = 5,
  eta = 0.1,
  subsample = 0.8,
  colsample_bytree = 0.8,
  min_child_weight = 5
)

bst <- xgb.train(
  params = params,
  data = dtrain,
  nrounds = 300,
  watchlist = list(train = dtrain, eval = dtest),
  verbose = 0,
  early_stopping_rounds = 25
)

mejor_iter <- bst$best_iteration
auc_eval   <- bst$best_score

knitr::kable(tibble(`Mejor iteraci√≥n` = mejor_iter, `AUC (eval)` = round(auc_eval,4)),
      caption = "Resumen del entrenamiento")
```

------------------------------------------------------------------------

## üìà Curva ROC y AUC

```{r}
p_test <- predict(bst, dtest)

roc_obj <- pROC::roc(response = test$compra, predictor = p_test,
                     levels = c("no","si"), direction = "<")
auc_val <- pROC::auc(roc_obj)

roc_df <- tibble(
  tpr = rev(roc_obj$sensitivities),
  fpr = rev(1 - roc_obj$specificities)
)

p_roc <- ggplot(roc_df, aes(x = fpr, y = tpr)) +
  geom_line(linewidth = 1) +
  geom_abline(linetype = 2) +
  labs(
    title = sprintf("Curva ROC (AUC = %.3f)", as.numeric(auc_val)),
    x = "Falsos positivos (1 - Especificidad)",
    y = "Verdaderos positivos (Sensibilidad)"
  )

plotly::ggplotly(p_roc, tooltip = c("x","y")) |>
  plotly::config(displayModeBar = FALSE)
```

------------------------------------------------------------------------

## ‚öñÔ∏è Calibraci√≥n (deciles)

```{r}
cal_df <- tibble(compra = test$compra, p = p_test) |>
  mutate(bin = ntile(p, 10)) |>
  group_by(bin) |>
  summarise(
    p_media   = mean(p),
    tasa_real = mean(compra == "si"),
    .groups   = "drop"
  )

p_cal <- ggplot(cal_df, aes(x = p_media, y = tasa_real)) +
  geom_point(size = 2) + geom_line() +
  geom_abline(linetype = 2) +
  scale_x_continuous(labels = percent_format(accuracy = 1)) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Calibraci√≥n (deciles)",
    x = "Probabilidad media predicha",
    y = "Tasa real de compra"
  )

plotly::ggplotly(p_cal, tooltip = c("x","y")) |>
  plotly::config(displayModeBar = FALSE)
```

------------------------------------------------------------------------

## üìà Ganancias acumuladas (Lift)

```{r}
lift_df <- tibble(compra = test$compra, p = p_test) |>
  arrange(desc(p)) |>
  mutate(
    obs = if_else(compra == "si", 1, 0),
    pct_pobl  = row_number() / n(),
    tasa_acum = cumsum(obs) / sum(obs)
  ) |>
  reframe(pct_pobl, tasa_acum)

p_lift <- ggplot(lift_df, aes(x = pct_pobl, y = tasa_acum)) +
  geom_line(linewidth = 1) +
  geom_abline(slope = 1, intercept = 0, linetype = 2) +
  scale_x_continuous(labels = percent_format(accuracy = 1)) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Ganancias acumuladas (modelo vs. azar)",
    x = "% de poblaci√≥n contactada (orden modelo)",
    y = "% de compras capturadas"
  )

plotly::ggplotly(p_lift, tooltip = c("x","y")) |>
  plotly::config(displayModeBar = FALSE)
```

------------------------------------------------------------------------

## üí∞ Capa prescriptiva (regla de negocio)

```{r}
# Supuestos de negocio (aj√∫stalos a tu realidad)
costo_contacto           <- 1.00   # USD por lead contactado
beneficio_por_compra     <- 70     # USD de margen si compra
efectividad_contacto     <- 0.35   # prob. de convertir si se contacta
presupuesto_total        <- 500    # USD disponibles

presc <- test |>
  mutate(p_compra = p_test) |>
  mutate(
    ev_contacto = p_compra * efectividad_contacto * beneficio_por_compra - costo_contacto
  ) |>
  arrange(desc(p_compra)) |>
  mutate(
    decision    = ev_contacto > 0,
    costo_inc   = if_else(decision, costo_contacto, 0),
    costo_acum  = cumsum(costo_inc),
    dentro_pres = costo_acum <= presupuesto_total
  ) |>
  filter(decision & dentro_pres)

resumen <- tibble(
  leads_a_contactar = nrow(presc),
  costo_total       = sum(presc$costo_inc),
  beneficio_esp     = sum(presc$p_compra * efectividad_contacto * beneficio_por_compra),
  ev_total          = sum(presc$ev_contacto)
)

knitr::kable(resumen, caption = "Resumen prescriptivo (contactos, costo, beneficio esperado y EV)")
```

------------------------------------------------------------------------

## üë§ Top 20 leads y Siguiente Mejor Acci√≥n

```{r}
top20 <- presc |>
  slice_head(n = 20) |>
  transmute(
    id_lead, segmento, region,
    visitas_web_30, emails_abiertos, demos_solicitadas, csat, precio_plan,
    prob_compra   = percent(p_compra, accuracy = 0.1),
    ev_contacto   = dollar(ev_contacto),
    accion_sugerida = case_when(
      segmento == "Enterprise" & demos_solicitadas == 1 ~ "Llamada ejecutiva + propuesta",
      segmento == "Mid"        & demos_solicitadas == 1 ~ "Demo 1:1 + onboarding guiado",
      segmento == "SMB"        & emails_abiertos >= 2   ~ "Secuencia email + descuento 10%",
      TRUE ~ "Email personalizado + CTA a demo"
    )
  )

# Contenedor que siempre hace scroll en m√≥vil
htmltools::div(
  style = "max-height:65vh; overflow:auto; width:100%;",
  DT::datatable(
    top20,
    rownames = FALSE,
    options = list(
      scrollY      = "55vh",
      scrollX      = TRUE,
      scrollCollapse = TRUE,
      paging       = FALSE,
      dom          = "t",
      autoWidth    = TRUE,
      deferRender  = TRUE
    ),
    class = "display nowrap compact",
    caption = htmltools::tags$caption(style = "caption-side: top; text-align: left;",
                                      "Top 20 leads priorizados y acci√≥n sugerida")
  )
)
```

------------------------------------------------------------------------

## üß≠ Storytelling de valor

1.  **Problema**: demasiados leads, recursos limitados.\
2.  **IA predictiva**: XGBoost estima probabilidad de compra por lead.\
3.  **Prescriptivo**: con costo, beneficio y presupuesto, maximizamos **EV**.\
4.  **Siguiente Mejor Acci√≥n**: t√°ctica recomendada por perfil/comportamiento.\
5.  **Impacto**: mayor ROI, decisiones basadas en datos.

------------------------------------------------------------------------

## ‚úÖ Conclusiones

-   La **IA en negocios** no solo predice: tambi√©n **prescribe**.\
-   Beneficios:
    -   Mejor **priorizaci√≥n de leads**.
    -   **Eficiencia** de presupuesto.
    -   **Mayor conversi√≥n** y retorno.

**De los datos ‚Üí a la acci√≥n ‚Üí al impacto.**
